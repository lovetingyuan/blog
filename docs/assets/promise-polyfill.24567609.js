export default'<h2 id="promise的polyfill实现">Promise的polyfill实现</h2>\n<pre><code class="language-javascript">// 用来resolve一个值，这个值可能是pomise,thenable或者其他\nfunction resolveValue (promise, value, resolve, reject) {\n  if (promise === value) { // 不能resolve自身\n    return reject(new TypeError(&#39;Can not resolve or return the current promise.&#39;))\n  }\n  if (value === null || (typeof value !== &#39;object&#39; &amp;&amp; typeof value !== &#39;function&#39;)) {\n    return resolve(value)\n  }\n  let then // thenable可能是对象或者函数，它的then只能读取一次并且需要捕获可能的错误\n  try {\n    then = value.then\n  } catch (err) {\n    return reject(err)\n  }\n  if (typeof then !== &#39;function&#39;) return resolve(value)\n  let called = false // 所有的回调只能调用一次\n  try { // 处理thenable，当然promise本身也是thenable\n    then.call(value, val =&gt; {\n      if (called) return\n      called = true\n      resolveValue(promise, val, resolve, reject) // 需要递归resolve，因为可能多次返回thenable\n    }, err =&gt; {\n      if (called) return\n      called = true\n      reject(err) // reject就直接调用即可\n    })\n  } catch (err) {\n    if (!called) reject(err)\n  }\n}\n\nfunction Promise (callback) {\n  if (!(this instanceof Promise)) throw new TypeError(&#39;Promise cannot be invoked without &quot;new&quot;.&#39;)\n  if (typeof callback !== &#39;function&#39;) throw new TypeError(&#39;Promise callback is not a function.&#39;)\n  this._status = &#39;pending&#39;\n  this._value = undefined\n  this._callbacks = { resolved: [], rejected: [] }\n  const settle = (status, value) =&gt; {\n    this._value = value\n    this._status = status\n    this._callbacks[status].forEach(cb =&gt; cb(value))\n  }\n  let called = false\n  const onResolve = value =&gt; {\n    if (called) return\n    called = true\n    resolveValue(this, value, val =&gt; settle(&#39;resolved&#39;, val), err =&gt; settle(&#39;rejected&#39;, err))\n  }\n  const onReject = err =&gt; {\n    if (called) return\n    called = true\n    settle(&#39;rejected&#39;, err)\n  }\n  try {\n    callback(onResolve, onReject)\n  } catch (err) {\n    onReject(err)\n  }\n}\n\nPromise.prototype.then = function then (onResolve, onReject) {\n  const handleCallback = (promise, status, resolve, reject) =&gt; {\n    const callback = status === &#39;resolved&#39; ? onResolve : onReject\n    const settle = status === &#39;resolved&#39; ? resolve : reject\n    setTimeout(() =&gt; { // then的回调需要延迟执行，实际应该放到微任务队列中\n      try {\n        if (typeof callback === &#39;function&#39;) {\n          resolveValue(promise, callback(this._value), resolve, reject)\n        } else {\n          settle(this._value)\n        }\n      } catch (err) {\n        reject(err)\n      }\n    })\n  }\n  let promise // then必须返回一个新的promise\n  if (this._status === &#39;pending&#39;) { // 如果是异步执行需要先把回调存储在队列中\n    promise = new Promise((resolve, reject) =&gt; {\n      this._callbacks.resolved.push(() =&gt; handleCallback(promise, &#39;resolved&#39;, resolve, reject))\n      this._callbacks.rejected.push(() =&gt; handleCallback(promise, &#39;rejected&#39;, resolve, reject))\n    })\n  } else {\n    let resolve, reject\n    promise = new Promise((...args) =&gt; [resolve, reject] = args)\n    handleCallback(promise, this._status, resolve, reject)\n  }\n  return promise\n}\n</code></pre>\n<hr>\n<p>以上是对<code>Promise</code>的简单实现，实际上Promise/A+规范只要求实例对象必须要有then方法，ES规范中还规定了一些静态和实例方法，这些都可以依赖Promise核心来实现</p>\n<ul>\n<li><code>Promise.prototype.catch</code><pre><code class="language-javascript">Promise.prototype.catch = function (onReject) {\n  return this.then(null, onReject)\n}\n</code></pre>\n</li>\n<li><code>Promise.prototype.finally</code><pre><code class="language-javascript">Promise.prototype.finally = function (callback) {\n  return this.then(val =&gt; {\n    return Promise.resolve(callback()).then(() =&gt; val)\n  }, err =&gt; {\n    return Promise.resolve(callback()).then(() =&gt; { throw err })\n  })\n}\n</code></pre>\n</li>\n<li><code>Promise.resolve</code> &amp; <code>Promise.reject</code><pre><code class="language-javascript">Promise.resolve = function resolve (val) {\n  return val instanceof Promise ? val : new Promise((resolve) =&gt; resolve(val))\n}\nPromise.reject = function reject (reason) {\n  return new Promise((_, reject) =&gt; reject(reason))\n}\n</code></pre>\n</li>\n<li><code>Promise.all</code><pre><code class="language-javascript">Promise.all = function all (values) {\n  return new Promise((resolve, reject) =&gt; {\n    // 实际上这里的values只要是可迭代对象就可以，这里简化了判断，其他方法也一样\n    if (!Array.isArray(values)) throw new TypeError(&#39;Promise.all only accepts iterable value.&#39;)\n    const resolvedValues = [], len = values.length\n    if (len === 0) return resolve(resolvedValues)\n    for (let i = 0; i &lt; len; i++) {\n      Promise.resolve(values[i]).then(val =&gt; {\n        resolvedValues[i] = val\n        if (i === len - 1) {\n          resolve(resolvedValues)\n        }\n      }, err =&gt; {\n        reject(err) // 一旦错过就不再\n      })\n    }\n  })\n}\n</code></pre>\n</li>\n<li><code>Promise.allSettled</code><pre><code class="language-javascript">Promise.allSettled = function allSettled (values) {\n  return new Promise((resolve) =&gt; {\n    if (!Array.isArray(values)) throw new TypeError(&#39;Promise.allSettled only accepts iterable value.&#39;)\n    const resolvedValues = [], len = values.length\n    if (len === 0) return resolve(resolvedValues)\n    for (let i = 0; i &lt; len; i++) {\n      Promise.resolve(values[i]).then(val =&gt; {\n        resolvedValues[i] = {\n          status: &#39;fulfilled&#39;, value: val\n        }\n        if (i === len - 1) {\n          resolve(resolvedValues)\n        }\n      }, err =&gt; {\n        resolvedValues[i] = {\n          status: &#39;rejected&#39;, reason: err\n        }\n        if (i === len - 1) {\n          resolve(resolvedValues)\n        }\n      })\n    }\n  })\n}\n</code></pre>\n</li>\n<li><code>Promise.race</code>，谁先结束就返回谁<pre><code class="language-javascript">Promise.race = function race (values) {\n  return new Promise((resolve, reject) =&gt; {\n    if (!Array.isArray(values)) throw new TypeError(&#39;Promise.race only accepts iterable value.&#39;)\n    for (let i = 0; i &lt; values.length; i++) {\n      Promise.resolve(values[i]).then(resolve, reject)\n    }\n  })\n}\n</code></pre>\n</li>\n<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any"><code>Promise.any</code></a>，和<code>Promise.all</code>在功能上是相反的，会尝试返回第一个成功的promise，如果都失败那就以<code>AggregateError</code>来reject<pre><code class="language-javascript">Promise.any = function any (values) {\n  return new Promise((resolve, reject) =&gt; {\n    if (!Array.isArray(values)) throw new TypeError(&#39;Promise.any only accepts iterable value.&#39;)\n    const resolvedReasons = [], len = values.length\n    if (len === 0) return reject(new AggregateError(resolvedReasons, &#39;All promises were rejected&#39;))\n    for (let i = 0; i &lt; len; i++) {\n      Promise.resolve(values[i]).then(val =&gt; {\n        resolve(val)\n      }, err =&gt; {\n        resolvedReasons[i] = err\n        if (i === len - 1) {\n          reject(new AggregateError(resolvedReasons, &#39;All promises were rejected&#39;))\n        }\n      })\n    }\n  })\n}\n</code></pre>\n</li>\n</ul>\n';
