export default'<h2 id="javascript继承实现">JavaScript继承实现</h2>\n<h3 id="es5的实现">ES5的实现</h3>\n<pre><code class="language-javascript">function Parent (name) {\n  this.name = name\n}\nParent.prototype.getName = function getName () { return this.name }\n\nfunction Child (name, age) {\n  Parent.call(this, name)\n  this.age = age\n}\nChild.prototype = Object.create(Parent.prototype, {\n  constructor: {\n    writable: true, configurable: true, enumerable: false,\n    value: Child\n  }\n})\nChild.prototype.getAge = function getAge () { return this.age }\n</code></pre>\n<h3 id="es6">ES6</h3>\n<p>对比于ES6规范中的class继承，上面的实现是少了一些细节的，看看Babel怎么弥补的</p>\n<pre><code class="language-javascript">class Parent {\n  static staticProp = &#39;static&#39;\n  static staticMethod() {}\n  constructor (a) { this.a = a }\n  instanceProp = &#39;instance&#39;\n  protoMethod() { console.log(this) }\n}\n\nclass Child extends Parent {\n  static staticChild = &#39;static&#39;\n  instanceChild = &#39;instance&#39;\n  static childStaticMethod () {\n    super.staticMethod()\n  }\n  constructor(a, b) {\n    super(a)\n      this.b = b\n  }\n  get getterProp() {}\n  protoMethod() { super.protoMethod() }\n}\n</code></pre>\n<p>Babel: </p>\n<pre><code class="language-javascript">\nvar Parent = /*#__PURE__*/function () {\n  // static的方法直接挂到Parent上，但是是不可枚举的\n  _createClass(Parent, null, [{\n    key: &quot;staticMethod&quot;,\n    value: function staticMethod() {}\n  }]);\n  function Parent(a) {\n    _classCallCheck(this, Parent); // 检查Parent不能直接调用\n    // 定义实例属性\n    _defineProperty(this, &quot;instanceProp&quot;, &#39;instance&#39;);\n    this.a = a;\n  }\n  // 将原型方法放到Parent的原型对象上，这里的方法都是不可枚举的\n  _createClass(Parent, [{\n    key: &quot;protoMethod&quot;,\n    value: function protoMethod() {\n      return &#39;parent proto&#39;;\n    }\n  }]);\n  return Parent;\n}();\n// 将静态属性挂到Parent构造方法上\n_defineProperty(Parent, &quot;staticProp&quot;, &#39;static&#39;);\n\nvar Child = /*#__PURE__*/function (_Parent) {\n  // _inherits实现了两条继承路径\n  // 一是原型继承，和ES5一样，即 Child.prototype = Object.create(Parent.prototype, {...\n  // 二是构造方法的原型继承，即 Child.__proto__ = _Parent，这样就可以Object.getPrototypeOf(Child) === Parent，那如果不存在继承，那__proto__自然指向的是Function.prototype\n  _inherits(Child, _Parent);\n  // function _createSuper(Derived) {\n  //   var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  //   return function _createSuperInternal() {\n  //     // 获取到父类的构造方法\n  //     var Super = _getPrototypeOf(Derived), result;\n  //     if (hasNativeReflectConstruct) {\n  //       var NewTarget = _getPrototypeOf(this).constructor;\n  //       result = Reflect.construct(Super, arguments, NewTarget);\n  //     } else {\n  //       result = Super.apply(this, arguments);\n  //     }\n  //     if (result &amp;&amp; (_typeof(result) === &quot;object&quot; || typeof result === &quot;function&quot;)) {\n  //       return result;\n  //     }\n  //     return _assertThisInitialized(this);\n  //   };\n  // }\n  // 创建父类的构造方法，这里是对父类构造方法做了包装，上面这段注释给出了_createSuper的具体实现\n  var _super = _createSuper(Child);\n  // 静态方法挂到Child上\n  _createClass(Child, null, [{\n    key: &quot;childStaticMethod&quot;,\n    value: function childStaticMethod() {\n      // 这里调用的是父类的方法\n      _get(_getPrototypeOf(Child), &quot;staticMethod&quot;, this).call(this);\n    }\n  }]);\n  function Child(a, b) {\n    var _this;\n    _classCallCheck(this, Child);\n    // 父类的构造方法在子类的上下文调用，这里会优先使用Reflect.construct()\n    // 使用Reflect可以实现先创建父类实例对象的效果，而不是拿着这里的this去调用父类构造方法，另一个好处是可以实现new.target\n    // 当然不支持Reflect就只能super.call(this)了\n    _this = _super.call(this, a);\n    // 判断_this一定要存在，代表super要先被调用才能用this，然后定义实例属性\n    _defineProperty(_assertThisInitialized(_this), &quot;instanceChild&quot;, &#39;instance&#39;);\n    _this.b = b;\n    return _this;\n  }\n  _createClass(Child, [{\n    key: &quot;protoMethod&quot;,\n    value: function protoMethod() {\n      _get(_getPrototypeOf(Child.prototype), &quot;protoMethod&quot;, this).call(this);\n    }\n  }, { // getter 属性是挂在到原型对象上的\n    key: &quot;getterProp&quot;,\n    get: function get() {}\n  }]);\n  return Child;\n}(Parent);\n_defineProperty(Child, &quot;staticChild&quot;, &#39;static&#39;);\n</code></pre>\n<p>Babel会尽量按照规范去实现，由此可以看出ES6继承带来的变化：</p>\n<ul>\n<li>ES6在实现原型继承的同时也会实现构造方法的继承，所以父类上的static属性子类也可以直接访问</li>\n<li>ES6在调用super的时候是先实例化父类，然后父类的实例对象在子类的构造方法上操作，ES5是反过来，ES6这样做主要目的是为了保留父类的一些内部属性和操作，比如继承内置对象时，如Array，那<code>class MyArray extends Array {}</code>，这里实例化MyArray后调用push那么它的length是会变化的，ES5无法做到这一点<blockquote>\n<p>子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法\nArray构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常。</p>\n</blockquote>\n</li>\n<li>ES6的原型方法和静态方法都是<strong>不可枚举</strong>的，这些方法也都没有原型对象；ES6支持getter，但是是<strong>在原型对象上</strong>定义set；class必须用new调用，默认启用严格模式，类名具有暂时性死区等等</li>\n</ul>\n<h3 id="super">super</h3>\n<p>额外说一下<code>super</code>，super本身是个关键字，但是在代码上它却无法独立使用（单独使用<code>super</code>时它什么也不代表），合法的只有两种访问形式：</p>\n<ul>\n<li>作为方法来调用，此时只能出现在子类构造方法中，也就是必须先调用super才能使用this；</li>\n<li>也可以作为“对象”来使用：<ul>\n<li>在原型方法（包括构造方法和getter）中：<ul>\n<li>访问super的属性时如<code>super.a</code>，这时的super<strong>代表的是this</strong>，也就是子类的实例对象</li>\n<li>访问super上的方法时它代表的是<strong>父类的原型对象</strong>，如<code>super.parentMethod()</code>，这里的parentMethod中的this指向的是子类的实例对象</li>\n</ul>\n</li>\n<li>在静态方法中访问super时它代表的是<strong>父类本身</strong>，如<code>super.staticParentMethod()</code>，这里的staticParentMethod中的this指向的是子类本身</li>\n</ul>\n</li>\n</ul>\n<p>不能以变量或者对象的眼光去看待super，super有自己的行事准则。</p>\n';
