[comment]: <browser> (title: 'v8引擎的垃圾回收', keywords: 'GC, ram', date: '2020-8-7')

### V8引擎的垃圾回收

代码运行时需要分配内存，通常会有三种分配策略，分别是静态分配，栈分配，堆分配，JS是高度动态的语言，所以V8会采用栈内存和堆内存来运行JS代码。

* 栈内存
栈内存主要存储一些基础类型变量和复杂对象的指针或者资源的句柄等。栈内存是一段连续的小内存，所以它不适合存放大量的数据，函数调用这种就适合用栈内存来存储，包括静态数据，上下文结构，临时变量等，函数调用完成后就会出栈，相应的栈空间就会被系统释放。V8中可以通过`--stack_size`来调整栈内存的大小。

* 堆内存
堆内存主要存储对象数据。V8把堆内存分成了几个部分，GC则发生在其中的 新生代空间 和 老生代空间 中：
  * 新生代空间：存储新生成的对象，这里的数据存活比较短，会经常被GC
  * 老生代空间：这里存储比较持久（经历两次新生代GC仍存活）的对象
  * 大对象空间：存放体积特别大（比其他空间都大）的对象，这里的对象不会被回收
  * 代码空间：存放代码，包括JIT编译的指令和运行信息
  * MAP空间：存储隐藏类（用来提升属性访问速度）

![alt](https://user-gold-cdn.xitu.io/2020/5/31/17269d61cb4ba88e)


V8的GC发生在新生代空间和老生代空间中，它们存放着我们代码中声明的大部分对象，包括变量对象和活动对象。之所以采取分代策略是因为对象的创建是频繁的，并且大部分生命都是短暂的，但是经过GC存活后一般认为继续用到的可能性比较大。

* 新生代空间
新生代空间是比较小的，它分成两个大小相同的部分（from区和to区），主要由Scavenger(Minor GC)来负责管理，也称为清道夫算法，采用Cheney算法实现，这是一种广度优先算法。空间的大小可以用`--min_semi_space_size`和`--max_semi_space_size`(KB)来设置。在64位系统中最大32MB，32位系统最多是16MB。

to这个半区是空的，from半区则是正在使用的区域，当from满了的时候，Minor GC就会清理from中无用的对象，然后将存活的对象复制到to中，这样to就变成了from，原来的from就变成了to。这个过程使用的便是Cheney算法。这个过程中如果对象经历了两次GC仍存活或者复制到to的时候to的占用达到了25%那么对象就会晋升到老生代空间中。

* 老生代空间
老生代空间存放的对象比较多，数据量比较大，采用的是不同的GC算法：Mark-Sweep & Mark-Compact(Major GC)，标记清除和标记整理。空间大小可以通过`--max_old_space_size`(MB)来设置。在64位系统中最大为1400MB，32位系统为700MB。V8之所以对内存大小限制的比较低一是因为浏览器环境内存用量一般没那么大，二是因为太大的堆内存会使得GC时间过长，阻塞代码的运行。老生代中的对象有两类，一类是包含指针的对象，新生代刚过来的对象一般就属于这一类，另一类是只包含数据的对象。

标记清除分为两个阶段，标记阶段首先会从已知的活动对象进行遍历，对存活的对象打上标记，清除阶段会对没有标记的对象直接清除。这样的过程多了会使得内存碎片越来越多导致可用空间越来越少，这时标记整理的过程会启动，标记存活的对象会被紧凑的移动到一端，然后清理剩余的内存。

如果标记的数量过多，V8会采用增量标记和延迟清理的策略，GC过程会暂停，避免程序停顿时间过长。V8采用强三色标记法来实现增量GC的过程。

上面就是V8垃圾回收运行的大体过程，实际的算法和策略是非常复杂的，包括并行标记，并发标记，新生代并行清除，老生代增量整理等等。
